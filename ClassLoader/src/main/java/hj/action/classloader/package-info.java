/**
 * <p>Title : Java虚拟机类加载机制</p>
 * <p>Description :
 * https://blog.csdn.net/u013256816/article/details/50829596
 *
 * 类加载过程：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段
 *              其中验证、准备、解析3个部分统称为连接（Linking）
 *              注：加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，
 *                  而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）
 *
 *  加载：java.lang.ClassLoader.loadClass()
 *      1、通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）
 *      2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
 *      3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
 *      注：加载阶段和连接阶段（Linking）的部分内容是交叉进行的，比如：部分字节码文件格式验证动作
 *          加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，
 *          然而，这两个阶段的开始时间仍然保持着固定的先后顺序。
 *
 *  验证：目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
 *      1、文件格式验证
 *      2、元数据验证
 *      3、字节码验证
 *      4、符号引用验证
 *      注：验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，
 *          如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
 *
 *  准备：正式为类变量(static) 分配内存并设置类变量初始值的阶段，类变量所使用的内存都将在方法区中进行分配。
 *      1、将类变量设置为初始"零"值
 *      2、对于 final static 变量，直接赋予真实值
 *
 *  解析：
 *      解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
 *      解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
 *
 *  初始化：类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码
 *      1、初始化阶段是执行类构造器<clinit>()方法的过程
 *          <clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的 --- 动态组织一个类构造器
 *          编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，
 *          定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
 *      2、虚拟机会保证在子类<cinit>()方法执行之前，父类的<clinit>()方法已经执行完毕
 *      3、<clinit>()方法对于类或者接口来说并不是必需的，
 *          如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<clinit>()方法。
 *      4、接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。
 *          但是接口的<clinit>()没有父子先后执行的要求，而且，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
 *      5、虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，
 *          如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，
 *          其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。并且保证，其他线程不会重复的执行<clinit>()，即：只会被初始化一次
 *          如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。
 *      6、JVM规范的5种初始化条件（jdk1.7）：
 *          6.1、遇到
 *              new ： 实例化对象,
 *              getstatic ： 读取类变量,
 *              putstatic ： 设置类变量,
 *              invokestatic ： 调用静态方法
 *              这4调字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
 *              注：当读取 final static 修饰的类变量时，不会触发 初始化
 *          6.2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
 *          6.3、当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
 *          6.4、当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
 *          6.5、当使用jdk1.7动态语言支持时，
 *              如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，
 *              并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。
 *
 *
 * 实例初始化 与 类初始化
 *   实例初始化<init>()是为创建对象实例执行实例字段赋值，执行普通代码块，执行构造函数。
 *   实例初始化不一定要在类初始化结束之后才开始初始化。
 *      比如：实例初始化的调用就在类变量赋值的过程中，或者说：静态初始化中内嵌构造初始化
 *          static MyClass st = new MyClass();
 *
 * </p>
 * <p>Date : 2019-01-31 </p>
 *
 * @author : hejie
 */
package hj.action.classloader;