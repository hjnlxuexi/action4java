/**
 * <p>Title : CAS: Compare And Swap</p>
 * <p>Description :
 *
 * 比较交换：
 *  1、内存值V = 内存地址valueOffset + 类型
 *  2、旧的预期值：A
 *  3、要更新的值：B
 *
 *  (V == A) -> B
 *
 *
 * 功能：
 *  保证读-改-写的原子性。
 *
 * 多CPU：
 *  1、总线加锁，阻塞其他CPU和内存的通讯，不可取
 *  2、缓存加锁，对它指定的内存地址进行缓存锁定
 *
 *
 * 缺陷：
 *  1、循环时间太长
 *      由于程序代码中对CAS的使用都是"自旋式"的。
 *      如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。
 *      在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。
 *
 *  2、只能保证一个共享变量的原子操作
 *      看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了。
 *      当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位。
 *
 *  3、ABA问题
 *      CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。
 *      但是存在这样一种情况：
 *          如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。
 *          对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —> B —> A，变成1A —> 2B —> 3A。
 *      解决：AtomicStampedReference
 * </p>
 * <p>Date : 2019-01-09 </p>
 *
 * @author : hejie
 */
package hj.action.concurrent.CAS;