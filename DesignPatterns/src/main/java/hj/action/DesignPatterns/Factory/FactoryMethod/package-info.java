/**
 * <p>Title : 工厂方法模式</p>
 * <p>Description :
 *
 *  工厂方法模式：
 *      定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式让实例化推迟到子类。
 *      工厂方法模式是简单工厂模式的延伸。在工厂方法模式中，核心工厂类不再负责产品的创建，而是将具体的创建工作交给子类去完成。
 *      这个核心工厂仅仅只是提供创建的接口，具体实现方法交给继承它的子类去完成。
 *      当我们的系统需要增加其他新的对象时，我们只需要添加一个具体的产品和它的创建工厂即可，不需要对原工厂进行任何修改，这样很好地符合了“开闭原则”。
 *
 *  =================================================================================================
 *  Product：抽象产品。
 *      所有的产品必须实现这个共同的接口，这样一来，使用这些产品的类既可以引用这个接口。而不是具体类。
 *  ConcreteProduct：具体产品。
 *  Creator：抽象工厂。
 *      它实现了所有操纵产品的方法，但不实现工厂方法。Creator所有的子类都必须要实现factoryMethod()方法。
 *  ConcreteCreator：具体工厂。
 *      制造产品的实际工厂。它负责创建一个或者多个具体产品，只有ConcreteCreator类知道如何创建这些产品。
 *
 *  =================================================================================================
 *  优点：
 *      1、在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。
 *      2、在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。
 *  缺点：
 *      每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。
 *      这并不是什么好事。
 *
 *  =================================================================================================
 *  适用场景：
 *      1、一个类不知道它所需要的对象的类。在工厂方法模式中，我们不需要具体产品的类名，我们只需要知道创建它的具体工厂即可。
 *      2、一个类通过其子类来指定创建那个对象。
 *          在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
 *      3、将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。
 *
 * </p>
 * <p>Date : 2019-02-13 </p>
 *
 * @author : hejie
 */
package hj.action.DesignPatterns.Factory.FactoryMethod;