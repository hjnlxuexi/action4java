/**
 * <p>Title : 解释器模型</p>
 * <p>Description :
 *
 *  所谓解释器模式就是定义语言的文法，并且建立一个解释器来解释该语言中的句子。
 *
 *  AbstractExpression: 抽象表达式。声明一个抽象的解释操作，该接口为抽象语法树中所有的节点共享。
 *  TerminalExpression: 终结符表达式。----数据
 *      实现与文法中的终结符相关的解释操作。
 *      实现抽象表达式中所要求的方法。
 *      文法中每一个 终结符 都有一个具体的终结表达式与之相对应。
 *  NonTerminalExpression: 非终结符表达式。为文法中的非终结符相关的解释操作。 ----运算符
 *  Context: 环境类。包含解释器之外的一些全局信息。
 *  Client: 客户类。
 *
 *  抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符和非终结符类。
 *  在解释器模式中由于每一种终结符表达式、非终结符表达式都会有一个具体的实例与之相对应，所以系统的扩展性比较好。
 *
 *  实例：
 *      重写 hj.action.stack.expression.Eval
 *
 *
 *  优点：
 *      1、可扩展性比较好，灵活。
 *      2、增加了新的解释表达式的方式。
 *      3、易于实现文法。
 *  缺点：
 *      1、执行效率比较低，可利用场景比较少。
 *      2、对于复杂的文法比较难维护。
 *
 * </p>
 * <p>Date : 2019-02-20 </p>
 *
 * @author : hejie
 */
package hj.action.DesignPatterns.Interpreter;