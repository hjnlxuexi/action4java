/**
 * <p>Title : 状态模式</p>
 * <p>Description :
 *
 *  面对状态系统的思维模式：
 *      1、正向思维： 通过行为来改变状态，同时状态也会限制行为，所以每一个行为中需要当前状态是否符合条件。当需要增加一种状态时，每个行为都可能会修改。
 *      2、逆向思维： 以状态作为原子对象，在状态对象中决定允许哪些行为
 *
 *  结构：
 *      1、Context: 环境类。可以包括一些内部状态。持有所有状态的实例，以及当前状态的引用，用于执行行为。
 *      2、State: 状态接口类。
 *          State定义了一个所有具体状态的共同接口，任何状态都实现这个相同的接口，这样一来，状态之间就可以互相转换了。
 *      3、ConcreteState: 具体状态类。持有环境类的引用，用于改变状态。
 *          用于处理来自Context的请求，每一个ConcreteState都提供了它对自己请求的实现，所以，当Context改变状态时行为也会跟着改变。
 *
 *  优点：
 *      1、封装了转换规则。
 *      2、枚举可能的状态，在枚举状态之前需要确定状态种类。
 *      3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。
 *      4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块，从 POP 到 OOP
 *  缺点：
 *      1、状态模式的使用必然会增加系统类和对象的个数。
 *      2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
 *      3、状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；
 *          而且修改某个状态类的行为也需修改对应类的源代码。
 *
 *  适用场景：
 *      1、对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。
 *      2、代码中包含大量与对象状态有关的条件语句
 *
 * </p>
 * <p>Date : 2019-02-15 </p>
 *
 * @author : hejie
 */
package hj.action.DesignPatterns.State;