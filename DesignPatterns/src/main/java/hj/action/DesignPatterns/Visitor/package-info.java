/**
 * <p>Title : 访问者模式</p>
 * <p>Description :
 *
 *  访问者模式：即表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
 *
 *  访问者模式适用于数据结构相对稳定的系统。
 *      它是将数据的操作与数据结构进行分离了，如果某个系统的数据结构相对稳定，但是操作算法易于变化的话，就比较适用适用访问者模式，
 *      因为访问者模式使得算法操作的增加变得比较简单了。
 *
 *  Visitor: 抽象访问者。为该对象结构中的ConcreteElement的每一个类声明的一个操作。
 *  ConcreteVisitor: 具体访问者。实现Visitor申明的每一个操作，每一个操作实现算法的一部分。
 *  Element: 抽象元素。定义一个Accept操作，它以一个访问者为参数。
 *  ConcreteElement: 具体元素 。实现Accept操作。
 *  ObjectStructure: 对象结构。能够枚举它的元素，可以提供一个高层的接口来允许访问者访问它的元素。
 *
 *  调用过程：
 *      客户端Client 持有--> 数据结构ObjectStructure 持有--> 元素Element 持有--> 访问者Visitor 调用--> visitor.visitElement(this)
 *
 *  优点：
 *      1、使得新增新的访问操作变得更加简单。
 *      2、能够使得用户在不修改现有类的层次结构下，定义该类层次结构的操作。
 *      3、将有关元素对象的访问行为集中到一个访问者对象中，而不是分散搞一个个的元素类中。
 *  优化：
 *      1、增加新的元素类很困难。
 *          在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了“开闭原则”的要求。
 *      2、破坏封装。当采用访问者模式的时候，就会打破组合类的封装。
 *      3、比较难理解。貌似是最难的设计模式了。
 *
 *  适用场景：
 *      1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。
 *      2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
 *
 *
 *  我觉得这是一个相反的状态模式。
 *      状态模式：固定操作，状态类型易扩展。
 *      访问者模式：操作易扩展，固定元素类型。
 *
 * </p>
 * <p>Date : 2019-02-19 </p>
 *
 * @author : hejie
 */
package hj.action.DesignPatterns.Visitor;